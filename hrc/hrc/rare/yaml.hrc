<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hrc PUBLIC "-//Cail Lomecb//DTD Colorer HRC take5//EN"
  "http://colorer.sf.net/2003/hrc.dtd">
<hrc version="take5"
     xmlns="http://colorer.sf.net/2003/hrc"
     xmlns:xinc="http://www.w3.org/2001/XInclude"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://colorer.sf.net/2003/hrc http://colorer.sf.net/2003/hrc.xsd">

<annotation>
    <documentation>
        YAML

        Home: https://github.com/chpock/ck.colorer-schemes
        Send requests there for bug fixes and features.
    </documentation>
    <contributors><![CDATA[
        Konstantin Kushnir <chpock@gmail.com>
    ]]></contributors>

    <appinfo>
        <prototype name="yaml" group="rare" description="YAML">
            <location link="rare/yaml.hrc"/>
            <filename weight="10">/\.ya?ml$/</filename>
        </prototype>
    </appinfo>
</annotation>

<type name="yaml">

<region name="Text" parent="def:Text"/>
<region name="Comment" parent="def:Comment"/>
<region name="String"  parent="def:String"/>
<region name="StringEdge" parent="def:StringEdge"/>
<region name="StringContent" parent="def:StringContent"/>
<region name="Constant"  parent="def:Constant"/>
<region name="BooleanConstant"  parent="def:BooleanConstant"/>

<region name="Symbol" parent="def:Symbol"/>
<region name="SymbolStrong" parent="def:SymbolStrong"/>

<region name="SymbolMapping" parent="def:SymbolStrong"/>
<region name="SymbolSequence" parent="def:Symbol"/>
<region name="SymbolMappingComplexKey" parent="def:Keyword"/>
<region name="SymbolTag" parent="def:Tag"/>
<region name="SymbolAnchor" parent="def:VarStrong"/>
<region name="SymbolFlow" parent="def:SymbolStrong"/>
<region name="SymbolMergeKeys" parent="def:InterfaceKeyword"/>

<region name="Tag" parent="def:OpenTag"/>
<region name="Anchor" parent="def:Var"/>

<region name="Error" parent="def:Error"/>

<region name="BlockScalar" parent="def:InterfaceKeyword"/>
<region name="BlockScalarIndent" parent="def:Prefix"/>


<region name="DocumentEdge" parent="def:Keyword"/>

<region name="MappingKey" parent="def:Parameter"/>

<!-- for testing -->
<region name="Test" parent="def:URL"/>
<region name="Test2" parent="def:TODO"/>

<!--

    This regexp is for floating-point base60 numbers (https://yaml.org/type/float.html)
        (?{def:NumberSuffix}[+-]?\d[\d_]*(:[0-5]?\d)+\.[\d_]*)

    This regexp is for integer base60 numbers (https://yaml.org/type/int.html)
        (?{def:NumberSuffix}[+-]?[1-9][\d_]*(:[0-5]?\d)+)

-->

<entity name="special-values" value="
    (
        (?{BooleanConstant}[tT]rue|TRUE|[fF]alse|FALSE|[yY]es|YES|[nN]o|NO|[oO]n|ON|[oO]ff|OFF)|
        (?{Constant}[nN]ull|NULL|\~)|
        (?{def:NumberFloat}\.nan|\.NaN|\.NAN|[+-]?\.[iI]nf|[+-]?\.INF)|
        (?{def:NumberFloat}[+-]?(\d[\d_]*)?\.\d[\d_]*([eE][+-]?[0-9]+)?)|
        (?{def:NumberFloat}[+-]?\d[\d_]*(\.|[eE][+-]?[0-9]+))|
        (?{def:NumberSuffix}[+-]?\d[\d_]*(:[0-5]?\d)+\.[\d_]*)|
        (?{def:NumberDec}[+-]?\d[\d_]*)|
        (?{def:NumberSuffix}[+-]?[1-9][\d_]*(:[0-5]?\d)+)|
        (?{def:NumberHex}0x[\da-fA-F][\da-fA-F_]*)|
        (?{def:NumberOct}0o?[0-7][0-7_]*)|
        (?{def:NumberBin}[+-]?0b[0-1][0-1_]*)|
        (?{def:Date}\d\d\d\d\-\d\d\-\d\d)|
            (?{def:Date}\d\d\d\d\-\d\d?\-\d\d?)
            (?{def:Prefix}[Tt]|[ \t]+)
            (?{def:Time}\d\d?:\d\d:\d\d(\.\d*)?)
            (?{def:Prefix}[ \t]*(Z|[+-]\d\d?(:\d\d)?))?
    )
"/>

<entity name="mapping-key" value="
    (
        (([^\s&quot;&apos;\-!&amp;\*\?\{\}\[\]]|[\-\?]\s?!)([^:#]*:\s?!)*[^:#]*)(:(\s|$))?=|
        (&quot;([^&quot;]*((\\&quot;)[^&quot;]*)*)&quot;)|
        (&apos;([^&apos;]*((&apos;&apos;)[^&apos;]*)*)&apos;)
    )\s*:
"/>

<!-- includes anchor reuse -->
<entity name="value-explicit" value="
    (
        \*|
        (!\S*\s+)?
        (&amp;\S*\s+)?
        [&quot;'\[\{]
    )
"/>

<entity name="value-block" value="
    (!\S*\s+)?
    (&amp;\S*\s+)?
    [&gt;\|]
"/>

<entity name="mapping-key-value-explicit" value="%mapping-key;\s+%value-explicit;"/>
<entity name="mapping-key-value-block" value="%mapping-key;\s+%value-block;"/>

<scheme name="yaml">

    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>

    <!-- directive %YAML -->
    <regexp><![CDATA[/
        ^
        (?{def:ClassKeyword}%YAML)\s+
        (?{def:NumberDec}\d+\.\d+)?
        (\s+#?=|\s*(?{Error}.*)$)
    /x]]></regexp>

    <!-- directive %TAG -->
    <regexp><![CDATA[/
        ^
        (?{def:ClassKeyword}%TAG)\s+
        ((?{SymbolTag}!)(?{Tag}\S*)\s+)?
        (?{String}\S+)?
        (\s+#?=|\s*(?{Error}.*)$)
    /x]]></regexp>

    <!-- unknown directive -->
    <regexp match="/^%.*$/" region="Error"/>

    <!-- document starts with a block scalar -->
    <block scheme="yaml-value-block">
        <start region1="DocumentEdge" region2="def:PairStart"><![CDATA[/
            ^((\-{3}))\s+
            \M%value-block;
        /x]]></start>
        <end region0="DocumentEdge" region3="def:PairEnd"><![CDATA[/
            ^(((\.{3})\s*(?{Error}([#\s]+)?!.*$)?)|(\-{3})?=|)
        /x]]></end>
    </block>

    <!-- document starts with an explicit value -->
    <block scheme="yaml-value-explicit">
        <start region1="DocumentEdge" region2="def:PairStart"><![CDATA[/
            ^((\-{3}))\s+
            \M%value-explicit;
        /x]]></start>
        <end region0="DocumentEdge" region3="def:PairEnd"><![CDATA[/
            ^(((\.{3})\s*(?{Error}([#\s]+)?!.*$)?)|(\-{3})?=|)
        /x]]></end>
    </block>

    <!-- document starts -->
    <block start="/^((\-{3}))(?{Error}\S*)\s*/" end="/^((\.{3})\s*(?{Error}([#\s]+)?!.*$)?)|(\-{3})?=/"
        scheme="yaml-value-implict"
        region01="DocumentEdge"  region10="DocumentEdge"
        region02="def:PairStart" region12="def:PairEnd"/>

    <inherit scheme="document"/>

</scheme>

<!-- these schemes can be overriden by parent scheme -->

<scheme name="key">
</scheme>

<scheme name="value">
</scheme>

<scheme name="string">
</scheme>

<scheme name="tag">
    <regexp match="/~!/" region="SymbolTag"/>
</scheme>

<scheme name="comment">
</scheme>

<scheme name="anchor">
</scheme>

<scheme name="string-double-quote">
    <regexp match="/\\(?{Error}\s+)$/"/>
    <regexp region="StringContent"><![CDATA[/
        \\((
            [0abtnvfre"/\\N_LP\x20]|
            (x[0-9a-fA-F]{2})|
            (u[0-9a-fA-F]{4})|
            (U[0-9a-fA-F]{8})
        )|$)
    /x]]></regexp>
    <inherit scheme="string"/>
</scheme>

<scheme name="string-single-quote">
    <regexp match="/&apos;&apos;/" region="StringContent"/>
    <inherit scheme="string"/>
</scheme>

<scheme name="key-double-quote">
    <inherit scheme="key"/>
    <inherit scheme="string-double-quote"/>
</scheme>

<scheme name="key-single-quote">
    <inherit scheme="key"/>
    <inherit scheme="string-single-quote"/>
</scheme>

<scheme name="key-plain">
    <inherit scheme="key"/>
    <regexp match="/~%special-values;:?=/x"/>
    <!-- eat colon without subsequent space -->
    <regexp match="/:(\s|$)?!/"/>
    <inherit scheme="string"/>
</scheme>

<scheme name="value-double-quote">
    <inherit scheme="string-double-quote"/>
</scheme>

<scheme name="value-single-quote">
    <inherit scheme="string-single-quote"/>
</scheme>

<scheme name="value-plain">
    <inherit scheme="value"/>
    <regexp match="/~%special-values;(\s*$|\s+#)?=/x"/>
    <!-- eat colon without subsequent space -->
    <regexp match="/:(\s|$)?!/"/>
    <inherit scheme="string"/>
</scheme>

<scheme name="value-plain-flow">
    <inherit scheme="value"/>
    <regexp match="/~%special-values;(\s*($|[,\]\}]))?=/x"/>
    <inherit scheme="string"/>
</scheme>

<scheme name="line-error">
    <!-- anything unexpected as an error -->
    <block start="/^\s*(?{Error}\S.*)?/" end="/\M^/" region01="Error" scheme="def:empty" priority="low"/>
</scheme>

<scheme name="line-string">
    <block start="/^\s+/" end="/\M^/" region="String" inner-region="yes" scheme="string" priority="low"/>
</scheme>

<scheme name="document">

    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>

    <!-- do not allow directives inside document -->
    <block start="/^%/" end="/\M^/" region="Error" scheme="def:empty" priority="low"/>

    <!-- comments -->
    <block start="/\s*\m#/" end="/\M^/" region="Comment" scheme="comment" priority="low"/>

    <!-- detect sequences/complex mappings -->
    <block start="/\M^(\s*)[\-\?:](\s+)\-(\s+)\-(\s+)\-(\s+)\-(\s|$)/" end="/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s)?!/"
        scheme="sequence-nested-4" priority="low"/>
    <block  start="/\M^(\s*)[\-\?:](\s+)\-(\s+)\-(\s+)\-(\s|$)/" end="/\M^(\y1\s\y2\s\y3\s\y4\s)?!/"
        scheme="sequence-nested-3" priority="low"/>
    <block start="/\M^(\s*)[\-\?:](\s+)\-(\s+)\-(\s|$)/" end="/\M^(\y1\s\y2\s\y3\s)?!/"
        scheme="sequence-nested-2" priority="low"/>
    <block start="/\M^(\s*)[\-\?:](\s+)\-(\s|$)/" end="/\M^(\y1\s\y2\s)?!/"
        scheme="sequence-nested-1" priority="low"/>
    <block start="/\M^(\s*)[\-\?:](\s|$)/" end="/\M^(\y1\s)?!/"
        scheme="sequence" priority="low"/>

    <!-- detect mergekeys mapping -->
    <block start="/^(\s*)\M&lt;&lt;\s*:/x" end="/\M^(\y1\s)?!/"
        scheme="mapping-mergekeys" priority="low"/>

    <!-- detect mapping with an explicit value -->
    <block start="/^(\s*)\M%mapping-key-value-explicit;/x" end="/\M^(\y1\s)?!/"
        scheme="mapping-value-explicit" priority="low"/>

    <!-- detect mapping with a value as a block scalar -->
    <block start="/^(\s*)\M%mapping-key-value-block;/x" end="/\M^(\y1\s)?!/"
        scheme="mapping-value-block" priority="low"/>

    <!-- detect mapping with an implicit value -->
    <block start="/^(\s*)\M%mapping-key;/x" end="/\M^(\y1\s)?!/"
        scheme="mapping-value-implict" priority="low"/>

    <!-- block value -->
    <block start="/^(\s*)\M%value-block;/x" end="/\M^(\y1\s)?!/" scheme="yaml-value-first-line" priority="low"/>

    <!-- explicit/implict value -->
    <block start="/^(\s*)\M\S/x" end="/\M^/" scheme="yaml-value-first-line" priority="low"/>

</scheme>

<scheme name="yaml-value-first-line">

    <!-- eat spaces -->
    <regexp match="/~\s+/"/>

    <!-- catch tags/anchors without name -->
    <regexp match="/([!\*&amp;](\s.*$|$))/" region1="Error"/>

    <block start="/!/" end="/\s+|$/" scheme="tag" region00="SymbolTag" region="Tag"/>
    <!-- do not allow a tag after an anchor -->
    <block start="/&amp;/" end="/\s+(?{Error}!\S*)?|$/" scheme="anchor" region00="SymbolAnchor" region="Anchor"/>
    <block start="/#/" end="/$/" scheme="comment" region="Comment"/>

    <!-- anything else is an actual value -->
    <block start="/.?#1.?=/" end="/$/" scheme="yaml-value-actual"/>
    <!--
        this is a special case where this schema is used in the "document" schema and
        then the value starts at the first character (the beginning of the line)
    -->
    <block start="/~.?=/" end="/$/" scheme="yaml-value-actual"/>

</scheme>

<scheme name="yaml-value-actual">

    <!-- eat spaces -->
    <regexp match="/\s+/"/>

    <!-- catch comments -->
    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>

    <!-- value - double quoted -->
    <block start="/(&quot;)/" end="/((&quot;))(\s*$|\s+#?=|\s*(?{Error}.*)$)/"
        scheme="value-double-quote" region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- value - single quoted -->
    <block start="/(&apos;)/" end="/((&apos;))(\s*$|\s+#?=|\s*(?{Error}.*)$)/"
        scheme="value-single-quote" region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- value - flow mapping -->
    <block start="/(\{)/" end="/((\}))(\s*$|\s+#?=|\s*(?{Error}.*)$)/"
        scheme="flow-mapping"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- value - flow sequence -->
    <block start="/(\[)/" end="/((\]))(\s*$|\s+#?=|\s*(?{Error}.*)$)/"
        scheme="flow-sequence"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- value - anchor reuse (after anchor reuse only a comment is allowed) -->
    <block start="/\*/" end="/\s*$|\s+#?=|\s+(?{Error}[^#].*?)?(\s+#|$)?=/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>

    <!-- value - block scalar -->
    <regexp match="/([&gt;\|])([+-])?(\d)?(\s*$|\s+#?=|\s*(?{Error}\S.*?)?(\s+#|$)?=)/"
        region1="BlockScalar" region2="BlockScalarIndent" region3="BlockScalarIndent"/>

    <!-- do not allow sequences/complex mapping here -->
    <regexp match="/[\-\?:]\s.*?(\s#|$)?=/" region="Error"/>

    <!-- value - plain scalar -->
    <block start="/\S?=/" end="/\s+#?=|$/" scheme="value-plain" region="String"/>

</scheme>

<scheme name="yaml-value-implict">

    <!--
        This is what we expect at the first line of the block.
        We are checking that we have at least 1 character in front of match,
        so here we will match something after a key, but not a newline.
    -->
    <block start="/.?#1.?=/" end="/$/" scheme="yaml-value-first-line"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <!--
         Note: we cannot rely on 'eat empty lines' in the 'document' schema, as
         that 'document' schema will be replaced in the yaml-value-explicit and
         yaml-value-block schemas, but this ignoring of empty lines rule
         should be active.
    -->
    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>

    <inherit scheme="document"/>

</scheme>

<scheme name="yaml-value-explicit">
    <inherit scheme="yaml-value-implict">
        <virtual scheme="document" subst-scheme="line-error"/>
    </inherit>
</scheme>

<scheme name="yaml-value-block">
    <inherit scheme="yaml-value-implict">
        <virtual scheme="document" subst-scheme="line-string"/>
    </inherit>
</scheme>

<scheme name="mapping-value-implict">

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <!-- double-quoted key, anything that is not a colon after a closing quote is an error -->
    <block start="/~(&quot;)/" end="/((&quot;))\s*(?{Error}[^:]*)(?{SymbolMapping}:)\s*/"
        scheme="key-double-quote" region="MappingKey"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- single-quoted key, anything that is not a colon after a closing quote is an error -->
    <block start="/~(&apos;)/" end="/((&apos;))\s*(?{Error}[^:]*)(?{SymbolMapping}:)\s*/"
        scheme="key-single-quote" region="MappingKey"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- plain key -->
    <block start="/~\M([^\s&quot;&apos;:!&amp;&gt;#\|\-]|[:\-]\s?!)/" end="/:(\s+|$)/"
        scheme="key-plain" region="MappingKey" region10="SymbolMapping"/>

    <inherit scheme="yaml-value-implict"/>

</scheme>

<scheme name="mapping-value-explicit">
    <inherit scheme="mapping-value-implict">
        <virtual scheme="yaml-value-implict" subst-scheme="yaml-value-explicit"/>
    </inherit>
</scheme>

<scheme name="mapping-value-block">
    <inherit scheme="mapping-value-implict">
        <virtual scheme="yaml-value-implict" subst-scheme="yaml-value-block"/>
    </inherit>
</scheme>

<scheme name="mapping-mergekeys">

    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <!-- merge keys is allowed here -->
    <regexp match="/~(&lt;&lt;)\s*(:)\s*/" region1="SymbolMergeKeys" region2="SymbolMapping"/>

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->

    <!-- catch tags/anchors without name -->
    <regexp match="/.?#1\s*([!\*&amp;](\s.*$|$))/" region1="Error"/>

    <!-- tags -->
    <block start="/.?#1!/" end="/\s*$|\s+/" scheme="tag" region00="SymbolTag" region="Tag"/>

    <!-- actual value as flow-sequence -->
    <block start="/.?#1(\[)/" end="/((\]))(\s*$|\s+#?=|\s*(?{Error}.*)$)/"
        scheme="flow-sequence-mergekeys"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- actual value as anchor reuse (after anchor reuse only a comment is allowed) -->
    <block start="/.?#1\*/" end="/\s*$|\s+#?=|\s+(?{Error}[^#].*)?$/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>

    <!-- comments -->
    <block start="/.?#1#/" end="/$/" scheme="comment" region="Comment"/>

    <!-- anything unexpected is an error -->
    <regexp match="/.?#1\s*(.+)$/" region1="Error"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <inherit scheme="line-error"/>

</scheme>

<scheme name="sequence">

    <!-- detect sequence with a value as mapping with an explicit value -->
    <block scheme="mapping-value-explicit" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        \M%mapping-key-value-explicit;
    /x" end="/\M^(\y1\s\y2\s)?!/"/>

    <!-- detect sequence with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-value-block" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        \M%mapping-key-value-block;
    /x" end="/\M^(\y1\s\y2\s)?!/"/>

    <!-- detect sequence with a value as mapping with an implicit value -->
    <block scheme="mapping-value-implict" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        \M%mapping-key;
    /x" end="/\M^(\y1\s\y2\s)?!/"/>

    <!-- detect sequence with an explicit value -->
    <block scheme="yaml-value-explicit" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        \M%value-explicit;
    /x" end="/\M^(\y1\s)?!/"/>

    <!-- detect sequence with a value as a block scalar -->
    <block scheme="yaml-value-block" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        \M%value-block;
    /x" end="/\M^(\y1\s)?!/"/>

    <!-- detect sequence with an implicit value -->
    <block scheme="yaml-value-implict" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+|$)
        \M(\-\s)?!
    /x" end="/\M^(\y1\s)?!/"/>

    <inherit scheme="document"/>

</scheme>

<scheme name="sequence-nested-1">

    <!-- detect sequence with a value as mapping with an explicit value -->
    <block scheme="mapping-value-explicit" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key-value-explicit;
    /x" end="/\M^(\y1\s\y2\s\y3\s)?!/"/>

    <!-- detect sequence with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-value-block" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key-value-block;
    /x" end="/\M^(\y1\s\y2\s\y3\s)?!/"/>

    <!-- detect sequence with a value as mapping with an implicit value -->
    <block scheme="mapping-value-implict" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key;
    /x" end="/\M^(\y1\s\y2\s\y3\s)?!/"/>

    <!-- detect sequence with an explicit value -->
    <block scheme="yaml-value-explicit" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%value-explicit;
    /x" end="/\M^(\y1\s\y2\s)?!/"/>

    <!-- detect sequence with a value as a block scalar -->
    <block scheme="yaml-value-block" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%value-block;
    /x" end="/\M^(\y1\s\y2\s)?!/"/>

    <!-- detect sequence with an implicit value -->
    <block scheme="yaml-value-implict" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+|$)
        \M(\-\s)?!
    /x" end="/\M^(\y1\s\y2\s)?!/"/>

    <inherit scheme="document"/>

</scheme>

<scheme name="sequence-nested-2">

    <!-- detect sequence with a value as mapping with an explicit value -->
    <block scheme="mapping-value-explicit" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key-value-explicit;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s)?!/"/>

    <!-- detect sequence with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-value-block" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key-value-block;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s)?!/"/>

    <!-- detect sequence with a value as mapping with an implicit value -->
    <block scheme="mapping-value-implict" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s)?!/"/>

    <!-- detect sequence with an explicit value -->
    <block scheme="yaml-value-explicit" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%value-explicit;
    /x" end="/\M^(\y1\s\y2\s\y3\s)?!/"/>

    <!-- detect sequence with a value as a block scalar -->
    <block scheme="yaml-value-block" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%value-block;
    /x" end="/\M^(\y1\s\y2\s\y3\s)?!/"/>

    <!-- detect sequence with an implicit value -->
    <block scheme="yaml-value-implict" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+|$)
        \M(\-\s)?!
    /x" end="/\M^(\y1\s\y2\s\y3\s)?!/"/>

    <inherit scheme="document"/>

</scheme>

<scheme name="sequence-nested-3">

    <!-- detect sequence with a value as mapping with an explicit value -->
    <block scheme="mapping-value-explicit" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key-value-explicit;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s)?!/"/>

    <!-- detect sequence with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-value-block" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key-value-block;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s)?!/"/>

    <!-- detect sequence with a value as mapping with an implicit value -->
    <block scheme="mapping-value-implict" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s)?!/"/>

    <!-- detect sequence with an explicit value -->
    <block scheme="yaml-value-explicit" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%value-explicit;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s)?!/"/>

    <!-- detect sequence with a value as a block scalar -->
    <block scheme="yaml-value-block" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%value-block;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s)?!/"/>

    <!-- detect sequence with an implicit value -->
    <block scheme="yaml-value-implict" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+|$)
        \M(\-\s)?!
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s)?!/"/>

    <inherit scheme="document"/>

</scheme>

<scheme name="sequence-nested-4">

    <!-- detect sequence with a value as mapping with an explicit value -->
    <block scheme="mapping-value-explicit" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key-value-explicit;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s\y6\s)?!/"/>

    <!-- detect sequence with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-value-block" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key-value-block;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s\y6\s)?!/"/>

    <!-- detect sequence with a value as mapping with an implicit value -->
    <block scheme="mapping-value-implict" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%mapping-key;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s\y6\s)?!/"/>

    <!-- detect sequence with an explicit value -->
    <block scheme="yaml-value-explicit" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%value-explicit;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s)?!/"/>

    <!-- detect sequence with a value as a block scalar -->
    <block scheme="yaml-value-block" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        \M%value-block;
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s)?!/"/>

    <!-- detect sequence with an implicit value -->
    <block scheme="yaml-value-implict" start="/
        ~(\s*)
        (?{}(?{SymbolSequence}\-)|(?{SymbolMappingComplexKey}[\?:]))(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+)
        (?{SymbolSequence}\-)(\s+|$)
        (?{SymbolSequence}\-)(\s+|$)
        \M(\-\s)?!
    /x" end="/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s)?!/"/>

    <inherit scheme="document"/>

</scheme>

<scheme name="flow-mapping">
    <!-- eat spaces -->
    <regexp match="/\s+/"/>
    <!-- comments without space is an error -->
    <block start="/\S?#1#/" end="/$|\}?=/" region="Error" scheme="def:empty"/>
    <!-- comments -->
    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>
    <!-- mapping key: merge key -->
    <block start="/(&lt;&lt;)\s*(:)/" end="/[,\}]?=/" scheme="flow-mapping-value-mergekeys"
        region01="SymbolMergeKeys" region02="SymbolMapping"/>
    <!-- mapping key: double quoted -->
    <block start="/((&quot;))/" end="/((&quot;))\s*(?{Error}[^:\}]*)/" scheme="key-double-quote"
        region="MappingKey"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- mapping key: single quoted -->
    <block start="/((&apos;))/" end="/((&apos;))\s*(?{Error}[^:\}]*)/" scheme="key-single-quote"
        region="MappingKey"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- mapping key: flow-sequence -->
    <block start="/((\[))/" end="/((\]))\s*(?{Error}[^:\}]*)/" scheme="flow-sequence"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- mapping key: flow-mapping -->
    <block start="/((\{))/" end="/((\}))\s*(?{Error}[^:\}]*)/" scheme="flow-mapping"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- mapping key: plain scalar -->
    <block start="/\M[^:,\}\s]/" end="/[,:\}]?=/" scheme="key-plain" region="MappingKey"/>

    <!-- allow comma, but do not allow another comma to be used after the found comma -->
    <regexp match="/,\s*(?{Error},[\s,]*)?/" region="Symbol"/>

    <!-- mapping value -->
    <block start="/:/" end="/[,\}]?=/" region00="SymbolMapping" scheme="flow-mapping-value"/>

    <!-- anything unexpected is an error -->
    <regexp match="/\S/" region="Error" priority="low"/>
</scheme>

<scheme name="flow-mapping-value-mergekeys">
    <!-- eat spaces -->
    <regexp match="/\s+/"/>
    <!-- comments without space is an error -->
    <block start="/\S?#1#/" end="/$|\}?=/" region="Error" scheme="def:empty"/>
    <!-- comments -->
    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>
    <!-- a tag, do not allow another tag to be used after the found tag -->
    <block start="/!/" end="/\s*$|\s+(?{Error}![^,\}]*)?/" scheme="tag" region00="SymbolTag" region="Tag"/>
    <!-- anchor, do not allow anything after the found anchor -->
    <block start="/\*/" end="/\s*[,\}]?=|\s+(?{Error}[^,\}]*)/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>
    <!-- nested flow-sequence, allow only comma or closing bracket after this match -->
    <block start="/(\[)/" end="/((\]))\s*(?{Error}[^,\}]*)/" scheme="flow-sequence-mergekeys"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- anything unexpected is an error -->
    <regexp match="/\S/" region="Error" priority="low"/>
</scheme>

<scheme name="flow-mapping-value">
    <!-- eat spaces -->
    <regexp match="/\s+/"/>
    <!-- comments without space is an error -->
    <block start="/\S?#1#/" end="/$|\}?=/" region="Error" scheme="def:empty"/>
    <!-- comments -->
    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>
    <!-- a tag, do not allow another tag to be used after the found tag -->
    <block start="/!/" end="/\s*$|\s+((?{Error}![^,\}\s]*)\s*)*/" scheme="tag" region00="SymbolTag" region="Tag"/>
    <!-- anchor, do not allow a tag/anchor/anchor reuse after the found anchor -->
    <block start="/&amp;/" end="/\s*$|\s+((?{Error}[!&amp;\*][^,\}\s]*)\s*)*/" scheme="anchor" region00="SymbolAnchor" region="Anchor"/>
    <!-- anchor reuse, do not allow anything after the found anchor reuse -->
    <block start="/\*/" end="/\s*[,\}]?=|\s+(?{Error}[^,\}]*)/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>
    <!-- nested flow-sequence, allow only comma or closing bracket after this match -->
    <block start="/(\[)/" end="/((\]))\s*(?{Error}[^,\}]*)/" scheme="flow-sequence"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- nested flow-mapping, allow only comma or closing bracket after this match -->
    <block start="/(\{)/" end="/((\}))\s*(?{Error}[^,\}]*)/" scheme="flow-mapping"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- double quoted value, allow only comma or closing bracket after this match -->
    <block start="/(&quot;)/" end="/((&quot;))\s*(?{Error}[^,\}]*)/" scheme="value-double-quote"
        region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- single quoted value, allow only comma or closing bracket after this match -->
    <block start="/(&apos;)/" end="/((&apos;))\s*(?{Error}[^,\}]*)/" scheme="value-single-quote"
        region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- plain scalar value -->
    <block start="/\M[^,\}\s]/" end="/[,\}]?=/" scheme="value-plain-flow" region="String"/>
    <!-- anything unexpected is an error -->
    <regexp match="/\S/" region="Error" priority="low"/>
</scheme>

<scheme name="flow-sequence">
    <!-- eat spaces -->
    <regexp match="/\s+/"/>
    <!-- comments without space is an error -->
    <block start="/\S?#1#/" end="/$|\]?=/" region="Error" scheme="def:empty"/>
    <!-- comments -->
    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>
    <!-- a tag, do not allow another tag to be used after the found tag -->
    <block start="/!/" end="/\s*$|\s+((?{Error}![^,\]\s]*)\s*)*/" scheme="tag" region00="SymbolTag" region="Tag"/>
    <!-- anchor, do not allow a tag/anchor/anchor reuse after the found anchor -->
    <block start="/&amp;/" end="/\s*$|\s+((?{Error}[!&amp;\*][^,\]\s]*)\s*)*/" scheme="anchor" region00="SymbolAnchor" region="Anchor"/>
    <!-- anchor, do not allow anything after the found anchor -->
    <block start="/\*/" end="/\s*[,\]]?=|\s+(?{Error}[^,\]]*)/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>
    <!-- nested flow-sequence, allow only comma or closing bracket after this match -->
    <block start="/(\[)/" end="/((\]))\s*(?{Error}[^,\]]*)/" scheme="flow-sequence"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- nested flow-mapping, allow only comma or closing bracket after this match -->
    <block start="/(\{)/" end="/((\}))\s*(?{Error}[^,\]]*)/" scheme="flow-mapping"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- double quoted value, allow only comma or closing bracket after this match -->
    <block start="/(&quot;)/" end="/((&quot;))\s*(?{Error}[^,\]]*)/" scheme="value-double-quote"
        region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- single quoted value, allow only comma or closing bracket after this match -->
    <block start="/(&apos;)/" end="/((&apos;))\s*(?{Error}[^,\]]*)/" scheme="value-single-quote"
        region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- allow comma, but do not allow another comma to be used after the found comma -->
    <regexp match="/,\s*(?{Error},[\s,]*)?/" region="Symbol"/>
    <!-- plain scalar value -->
    <block start="/\M[^,\]\s]/" end="/[,\]]?=/" scheme="value-plain-flow" region="String"/>
    <!-- anything unexpected is an error -->
    <regexp match="/\S/" region="Error" priority="low"/>
</scheme>

<scheme name="flow-sequence-mergekeys">
    <!-- eat spaces -->
    <regexp match="/\s+/"/>
    <!-- comments without space is an error -->
    <block start="/\S?#1#/" end="/$|\]?=/" region="Error" scheme="def:empty"/>
    <!-- comments -->
    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>
    <!-- anchor, do not allow anything after the found anchor -->
    <block start="/\*/" end="/\s*[,\]]?=|\s+(?{Error}[^,\]]*)/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>
    <!-- allow comma, but do not allow another comma to be used after the found comma -->
    <regexp match="/,\s*(?{Error},[\s,]*)?/" region="Symbol"/>
    <!-- anything unexpected is an error -->
    <regexp match="/\S/" region="Error" priority="low"/>
</scheme>

</type>
</hrc>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Colorer Library.
   -
   - The Initial Developer of the Original Code is
   - Cail Lomecb <cail@nm.ru>.
   - Portions created by the Initial Developer are Copyright (C) 1999-2008
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   - Konstantin Kushnir <chpock@gmail.com>.
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->
