<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hrc PUBLIC "-//Cail Lomecb//DTD Colorer HRC take5//EN"
  "http://colorer.sf.net/2003/hrc.dtd">
<hrc version="take5"
     xmlns="http://colorer.sf.net/2003/hrc"
     xmlns:xinc="http://www.w3.org/2001/XInclude"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://colorer.sf.net/2003/hrc http://colorer.sf.net/2003/hrc.xsd">

<annotation>
    <documentation>
        YAML

        Home: https://github.com/chpock/ck.colorer-schemes
        Send requests there for bug fixes and features.
    </documentation>
    <contributors><![CDATA[
        Konstantin Kushnir <chpock@gmail.com>
    ]]></contributors>

    <appinfo>
        <prototype name="yaml" group="rare" description="YAML">
            <location link="rare/yaml.hrc"/>
            <filename weight="10">/\.ya?ml$/</filename>
        </prototype>
    </appinfo>
</annotation>

<type name="yaml">

<region name="Text" parent="def:Text"/>
<region name="Comment" parent="def:Comment"/>
<region name="String"  parent="def:String"/>
<region name="StringEdge" parent="def:StringEdge"/>
<region name="StringContent" parent="def:StringContent"/>
<region name="Constant"  parent="def:Constant"/>
<region name="BooleanConstant"  parent="def:BooleanConstant"/>

<region name="Symbol" parent="def:Symbol"/>
<region name="SymbolStrong" parent="def:SymbolStrong"/>

<region name="SymbolMapping" parent="def:SymbolStrong"/>
<region name="SymbolSequence" parent="def:Symbol"/>
<region name="SymbolMappingComplexKey" parent="def:Symbol"/>
<region name="SymbolTag" parent="def:Tag"/>
<region name="SymbolAnchor" parent="def:VarStrong"/>
<region name="SymbolFlow" parent="def:SymbolStrong"/>
<region name="SymbolMergeKeys" parent="def:InterfaceKeyword"/>

<region name="Tag" parent="def:OpenTag"/>
<region name="Anchor" parent="def:Var"/>

<region name="Error" parent="def:Error"/>

<region name="BlockScalar" parent="def:InterfaceKeyword"/>
<region name="BlockScalarIndent" parent="def:Prefix"/>


<region name="DocumentEdge" parent="def:Keyword"/>

<region name="MappingKey" parent="def:Parameter"/>

<!-- region name="Variable" parent="def:Var"/>
<region name="Constant" parent="def:Constant"/>

<region name="SectionMain" parent="def:ClassKeyword"/>
<region name="KeywordResource" parent="def:Keyword"/>
<region name="Identifier" parent="def:Identifier"/>

<region name="SymbolLiteral" parent="def:Operator"/>
<region name="SymbolLiteralIndentLevel" parent="def:Prefix"/ -->

<!-- for testing -->
<region name="Test" parent="def:URL"/>
<region name="Test2" parent="def:TODO"/>

<!--

    This regexp is for floating-point base60 numbers (https://yaml.org/type/float.html)
        (?{def:NumberSuffix}[+-]?\d[\d_]*(:[0-5]?\d)+\.[\d_]*)

    This regexp is for integer base60 numbers (https://yaml.org/type/int.html)
        (?{def:NumberSuffix}[+-]?[1-9][\d_]*(:[0-5]?\d)+)

-->

<entity name="special-values" value="
    (
        (?{BooleanConstant}[tT]rue|TRUE|[fF]alse|FALSE|[yY]es|YES|[nN]o|NO|[oO]n|ON|[oO]ff|OFF)|
        (?{Constant}[nN]ull|NULL|\~)|
        (?{def:NumberFloat}\.nan|\.NaN|\.NAN|[+-]?\.[iI]nf|[+-]?\.INF)|
        (?{def:NumberFloat}[+-]?(\d[\d_]*)?\.\d[\d_]*([eE][+-]?[0-9]+)?)|
        (?{def:NumberFloat}[+-]?\d[\d_]*(\.|[eE][+-]?[0-9]+))|
        (?{def:NumberSuffix}[+-]?\d[\d_]*(:[0-5]?\d)+\.[\d_]*)|
        (?{def:NumberDec}[+-]?\d[\d_]*)|
        (?{def:NumberSuffix}[+-]?[1-9][\d_]*(:[0-5]?\d)+)|
        (?{def:NumberHex}0x[\da-fA-F][\da-fA-F_]*)|
        (?{def:NumberOct}0o?[0-7][0-7_]*)|
        (?{def:NumberBin}[+-]?0b[0-1][0-1_]*)|
        (?{def:Date}\d\d\d\d\-\d\d\-\d\d)|
            (?{def:Date}\d\d\d\d\-\d\d?\-\d\d?)
            (?{def:Prefix}[Tt]|[ \t]+)
            (?{def:Time}\d\d?:\d\d:\d\d(\.\d*)?)
            (?{def:Prefix}[ \t]*(Z|[+-]\d\d?(:\d\d)?))?
    )
"/>

<!--
        (([^\s&quot;&apos;\-!&amp;\*\?\{\}\[\]]|\-\s?!)([^:\{\}\[\]]*:\s?!)*[^:\{\}\[\]]*)|
-->

<entity name="mapping-key" value="
    (
        (([^\s&quot;&apos;\-!&amp;\*\?\{\}\[\]]|\-\s?!)([^:]*:\s?!)*[^:]*)|
        (&quot;([^&quot;]*((\\&quot;)[^&quot;]*)*)&quot;)|
        (&apos;([^&apos;]*((&apos;&apos;)[^&apos;]*)*)&apos;)
    )\s*:
"/>

<scheme name="yaml">

    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>

    <!-- directive %YAML -->
    <regexp><![CDATA[/
        ^
        (?{def:ClassKeyword}%YAML)\s+
        (?{def:NumberDec}\d+\.\d+)?
        (\s+#?=|\s*(?{Error}.*)$)
    /x]]></regexp>

    <!-- directive %TAG -->
    <regexp><![CDATA[/
        ^
        (?{def:ClassKeyword}%TAG)\s+
        ((?{SymbolTag}!)(?{Tag}\S*)\s+)?
        (?{String}\S+)?
        (\s+#?=|\s*(?{Error}.*)$)
    /x]]></regexp>

    <!-- unknown directive -->
    <regexp match="/^%.*$/" region="Error"/>

    <!-- document start with block scalar -->
    <!-- block scheme="block-scalar">
        <start region1="DocumentEdge" region2="def:PairStart"><![CDATA[/
            ^((\-{3}))\s+\M
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^\S/]]></end>
    </block -->

    <!-- document start with value as "... / '... / {... / [.... -->
    <!-- block scheme="block-not-plain">
        <start region1="DocumentEdge" region2="def:PairStart"><![CDATA[/
            ^((\-{3}))\s+\M
            (!\S*\s+)?
            (&\S*\s+)?
            ["'\[\{]
        /x]]></start>
        <end region0="DocumentEdge" region2="def:PairEnd"><![CDATA[/
            ^((\.{3})\s*(?{Error}([#\s]+)?!.*$)?)|(\-{3})?=
        /x]]></end>
    </block -->

    <!-- document start with plain value -->
    <!-- block scheme="block-plain">
        <start region1="DocumentEdge" region2="def:PairStart"><![CDATA[/
            ^((\-{3}))\s+\M
            (!\S*\s+)?
            (&\S*\s+)?
            [^\s#]
        /xs]]></start>
        <end region0="DocumentEdge" region2="def:PairEnd"><![CDATA[/
            ^((\.{3})\s*(?{Error}([#\s]+)?!.*$)?)|(\-{3})?=
        /x]]></end>
    </block -->

    <!-- document start with optional comment -->
    <block start="/^(\-{3})\s*(?{Error}([#\s]+)?!.*$)?/" end="/^((\.{3})\s*(?{Error}([#\s]+)?!.*$)?)|(\-{3})?=/"
        scheme="document"
        region00="DocumentEdge"  region10="DocumentEdge"
        region01="def:PairStart" region12="def:PairEnd"/>

    <inherit scheme="document"/>

</scheme>

<!-- these schemes can be overriden by parent scheme -->

<scheme name="key">
</scheme>

<scheme name="value">
</scheme>

<scheme name="string">
</scheme>

<scheme name="tag">
    <regexp match="/~!/" region="SymbolTag"/>
</scheme>

<scheme name="comment">
</scheme>

<scheme name="anchor">
</scheme>

<scheme name="string-double-quote">
    <regexp region="StringContent"><![CDATA[/
        \\(
            [0abtnvfre"/\\N_LP\x20]|
            (x[0-9a-fA-F]{2})|
            (u[0-9a-fA-F]{4})|
            (U[0-9a-fA-F]{8})
        )
    /x]]></regexp>
    <inherit scheme="string"/>
</scheme>

<scheme name="string-single-quote">
    <regexp match="/&apos;&apos;/" region="StringContent"/>
    <inherit scheme="string"/>
</scheme>

<scheme name="key-double-quote">
    <inherit scheme="key"/>
    <inherit scheme="string-double-quote"/>
</scheme>

<scheme name="key-single-quote">
    <inherit scheme="key"/>
    <inherit scheme="string-single-quote"/>
</scheme>

<scheme name="key-plain">
    <inherit scheme="key"/>
    <regexp match="/~%special-values;:?=/x"/>
    <!-- eat colon without subsequent space -->
    <regexp match="/:(\s|$)?!/"/>
    <inherit scheme="string"/>
</scheme>

<scheme name="value-double-quote">
    <inherit scheme="string-double-quote"/>
</scheme>

<scheme name="value-single-quote">
    <inherit scheme="string-single-quote"/>
</scheme>

<scheme name="value-plain">
    <inherit scheme="value"/>
    <regexp match="/~%special-values;(\s*$|\s+#)?=/x"/>
    <!-- eat colon without subsequent space -->
    <regexp match="/:(\s|$)?!/"/>
    <inherit scheme="string"/>
</scheme>

<scheme name="value-plain-flow">
    <inherit scheme="value"/>
    <regexp match="/~%special-values;(\s*($|[,\]\}]))?=/x"/>
    <inherit scheme="string"/>
</scheme>

<scheme name="badLine">
    <!-- eat empty lines or mark enything unexpected as an error -->
    <block start="/^\s*\M\S/" end="/\M^/" region="Error" inner-region="yes" scheme="def:empty" priority="low"/>
</scheme>

<scheme name="document">

    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>

    <!-- detect sequences -->
    <block start="/\M^(\s*)\-(\s*)\-(\s*)\-(\s*)\-(\s|$)/" end="/\M^(\y1\s\y2\s\y3\s\y4\-(\s|$))?!/"
        scheme="sequence-nested-3" priority="low"/>
    <block start="/\M^(\s*)\-(\s*)\-(\s*)\-(\s|$)/" end="/\M^(\y1\s\y2\s\y3\-(\s|$))?!/"
        scheme="sequence-nested-2" priority="low"/>
    <block start="/\M^(\s*)\-(\s*)\-(\s|$)/" end="/\M^(\y1\s\y2\-(\s|$))?!/"
        scheme="sequence-nested-1" priority="low"/>
    <block start="/\M^(\s*)\-(\s|$)/" end="/\M^(\y1\-(\s|$))?!/"
        scheme="sequence" priority="low"/>

    <!-- detect complex mapping -->
    <block start="/\M^(\s*)[\?:](\s|$)/" end="/\M^(\y1[\?:])?!/" scheme="complex" priority="low"/>

    <block scheme="mapping-mergekeys" priority="low">
        <start><![CDATA[/
            ^(\s*)\M
            <<\s*:
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s)?!/]]></end>
    </block>

    <!-- detect mapping without a value -->
    <block scheme="mapping-without-value" priority="low">
        <start><![CDATA[/
            ^(\s*)\M
            %mapping-key;
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s)?!/]]></end>
    </block>

    <!-- detect mapping with a value as a block scalar -->
    <block scheme="mapping-with-value-block-scalar" priority="low">
        <start><![CDATA[/
            ^(\s*)\M
            %mapping-key;
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s)?!/]]></end>
    </block>

    <!-- detect mapping with a value -->
    <block scheme="mapping-with-value" priority="low">
        <start><![CDATA[/
            ^(\s*)\M
            %mapping-key;
            \s
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s)?!/]]></end>
    </block>

    <block start="/^\s*#/" end="/\M^/" region="Comment" scheme="comment" priority="low"/>

    <inherit scheme="badLine"/>

</scheme>

<scheme name="mapping-key">

    <!-- double-quoted key, anything that is not a colon after a closing quote is an error -->
    <block start="/~(&quot;)/" end="/((&quot;))\s*(?{Error}[^:])?/"
        scheme="key-double-quote" region="MappingKey"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- single-quoted key, anything that is not a colon after a closing quote is an error -->
    <block start="/~(&apos;)/" end="/((&apos;))\s*(?{Error}[^:])?/"
        scheme="key-single-quote" region="MappingKey"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- plain key -->
    <block start="/~\M([^\s&quot;&apos;:!&amp;&gt;#\|\-]|[:\-]\s?!)/" end="/(:(\s|$))?=/"
        scheme="key-plain" region="MappingKey"/>

</scheme>

<scheme name="mapping-key-after">

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->

    <!-- catch tags/anchors without name -->
    <regexp match="/.?#1([!\*&amp;](\s.*$|$))/" region1="Error"/>

    <regexp match="/.?#1:(\s+|\s*$)/" region="SymbolMapping"/>

    <block start="/.?#1!/" end="/\s+|$/" scheme="tag" region00="SymbolTag" region="Tag"/>
    <block start="/.?#1&amp;/" end="/\s+|$/" scheme="anchor" region00="SymbolAnchor" region="Anchor"/>
    <block start="/.?#1#/" end="/$/" scheme="comment" region="Comment"/>

</scheme>

<scheme name="yaml-value">

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->

    <!-- eat spaces -->
    <regexp match="/.?#1\s+/"/>

    <!-- catch comments -->
    <block start="/.?#1#/" end="/$/" region="Comment" scheme="comment"/>

    <!-- value - double quoted -->
    <block start="/.?#1(&quot;)/" end="/((&quot;))(\s*$|\s+#?=|\s*(?{Error}.*)$)/"
        scheme="value-double-quote" region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- value - single quoted -->
    <block start="/.?#1(&apos;)/" end="/((&apos;))(\s*$|\s+#?=|\s*(?{Error}.*)$)/"
        scheme="value-single-quote" region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- value - flow mapping -->
    <block start="/.?#1(\{)/" end="/((\}))(\s*$|\s+#?=|\s*(?{Error}.*)$)/"
        scheme="flow-mapping"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- value - flow sequence -->
    <block start="/.?#1(\[)/" end="/((\]))(\s*$|\s+#?=|\s*(?{Error}.*)$)/"
        scheme="flow-sequence"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- value - anchor reuse (after anchor reuse only a comment is allowed) -->
    <block start="/.?#1\*/" end="/\s*$|\s+#?=|\s+(?{Error}[^#].*)?$/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>

    <!-- value - plain scalar -->
    <block start="/.?#1\S?=/" end="/\s+#?=|$/" scheme="value-plain" region="String"/>

</scheme>

<scheme name="mapping-without-value">

    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <inherit scheme="mapping-key"/>

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->
    <inherit scheme="mapping-key-after"/>

    <!-- anything unexpected is an error -->
    <regexp match="/.?#1\s*(.+)$/" region1="Error"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <inherit scheme="document"/>

</scheme>

<scheme name="mapping-with-value-block-scalar">

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <inherit scheme="mapping-key"/>

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->
    <inherit scheme="mapping-key-after"/>

    <regexp match="/([&gt;\|])([+-])?(\d)?(\s*$|\s+#?=|\s*(?{Error}\S.*)?$)/"
        region1="BlockScalar" region2="BlockScalarIndent" region3="BlockScalarIndent"/>

    <!-- anything unexpected is an error -->
    <regexp match="/.?#1\s*(.+)$/" region1="Error"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>
    <!-- everyting else is a string -->
    <block start="/^\s+/" end="/\M^/" scheme="string" region="String" priority="low"/>

</scheme>

<scheme name="mapping-with-value">

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <inherit scheme="mapping-key"/>

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->
    <inherit scheme="mapping-key-after"/>

    <inherit scheme="yaml-value"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <inherit scheme="badLine"/>

</scheme>

<scheme name="mapping-mergekeys">

    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <!-- merge keys is allowed here -->
    <regexp match="/~(&lt;&lt;)\s*(:)\s*/" region1="SymbolMergeKeys" region2="SymbolMapping"/>

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->

    <!-- catch tags/anchors without name -->
    <regexp match="/.?#1\s*([!\*&amp;](\s.*$|$))/" region1="Error"/>

    <!-- tags -->
    <block start="/.?#1!/" end="/\s*$|\s+/" scheme="tag" region00="SymbolTag" region="Tag"/>

    <!-- actual value as flow-sequence -->
    <block start="/.?#1(\[)/" end="/((\]))(\s*$|\s+#?=|\s*(?{Error}.*)$)/"
        scheme="flow-sequence-mergekeys"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>

    <!-- actual value as anchor reuse (after anchor reuse only a comment is allowed) -->
    <block start="/.?#1\*/" end="/\s*$|\s+#?=|\s+(?{Error}[^#].*)?$/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>

    <!-- comments -->
    <block start="/.?#1#/" end="/$/" scheme="comment" region="Comment"/>

    <!-- anything unexpected is an error -->
    <regexp match="/.?#1\s*(.+)$/" region1="Error"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <inherit scheme="badLine"/>

</scheme>

<scheme name="sequence">

    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>

    <!-- detect sequence without a value -->
    <block scheme="sequence-without-value" priority="low">
        <start><![CDATA[/
            ^(\s*)\M
            \-
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a block scalar -->
    <block scheme="sequence-with-value-block-scalar" priority="low">
        <start><![CDATA[/
            ^(\s*)\M
            \-
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping without a value -->
    <block scheme="mapping-without-value" priority="low">
        <start><![CDATA[/
            ^(\s*)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-with-value-block-scalar" priority="low">
        <start><![CDATA[/
            ^(\s*)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a mapping with a value -->
    <block scheme="mapping-with-value" priority="low">
        <start><![CDATA[/
            ^(\s*)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value -->
    <block scheme="sequence-with-value" priority="low">
        <start><![CDATA[/
            ^(\s*)
            \M\-
            \s+
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s)?!/]]></end>
    </block>

    <inherit scheme="badLine"/>

</scheme>

<scheme name="sequence-nested-1">

    <!-- detect sequence without a value -->
    <block scheme="sequence-without-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)
            \M\-
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a block scalar -->
    <block scheme="sequence-with-value-block-scalar">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)
            \M\-
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping without a value -->
    <block scheme="mapping-without-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-with-value-block-scalar">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a mapping with a value -->
    <block scheme="mapping-with-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value -->
    <block scheme="sequence-with-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)
            \M\-
            \s+
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <inherit scheme="sequence"/>

</scheme>

<scheme name="sequence-nested-2">

    <!-- detect sequence without a value -->
    <block scheme="sequence-without-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            \M\-
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a block scalar -->
    <block scheme="sequence-with-value-block-scalar">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            \M\-
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping without a value -->
    <block scheme="mapping-without-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-with-value-block-scalar">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a mapping with a value -->
    <block scheme="mapping-with-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value -->
    <block scheme="sequence-with-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            \M\-
            \s+
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <inherit scheme="sequence"/>

</scheme>

<scheme name="sequence-nested-3">

    <!-- detect sequence without a value -->
    <block scheme="sequence-without-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            \M\-
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a block scalar -->
    <block scheme="sequence-with-value-block-scalar">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            \M\-
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping without a value -->
    <block scheme="mapping-without-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-with-value-block-scalar">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a mapping with a value -->
    <block scheme="mapping-with-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s\y5\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value -->
    <block scheme="sequence-with-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)(?{SymbolSequence}\-)(\s+)
            \M\-
            \s+
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s)?!/]]></end>
    </block>

    <inherit scheme="sequence"/>

</scheme>

<scheme name="sequence-without-value">

    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <regexp match="/~\-(\s+|\s*$)/" region="SymbolSequence"/>

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->
    <inherit scheme="mapping-key-after"/>

    <!-- anything unexpected is an error -->
    <regexp match="/.?#1\s*(.+)$/" region1="Error"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <inherit scheme="document"/>

</scheme>


<scheme name="sequence-with-value-block-scalar">

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <regexp match="/~\-(\s+|\s*$)/" region="SymbolSequence"/>

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->
    <inherit scheme="mapping-key-after"/>

    <regexp match="/([&gt;\|])([+-])?(\d)?(\s*$|\s+#?=|\s*(?{Error}\S.*)?$)/"
        region1="BlockScalar" region2="BlockScalarIndent" region3="BlockScalarIndent"/>

    <!-- anything unexpected is an error -->
    <regexp match="/.?#1\s*(.+)$/" region1="Error"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>
    <!-- everyting else is a string -->
    <block start="/^\s+/" end="/\M^/" scheme="string" region="String" priority="low"/>

</scheme>

<scheme name="sequence-with-value">

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <regexp match="/~\-(\s+|\s*$)/" region="SymbolSequence"/>

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->
    <inherit scheme="mapping-key-after"/>
    <inherit scheme="yaml-value"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <inherit scheme="badLine"/>

</scheme>

<scheme name="complex">

    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>

    <!-- detect complex-mapping with a sequence as a value -->
    <block start="/^\M(\s*)[\?:](\s+)\-(\s+)\-(\s|$)/x" end="/\M^(\y1\s\y2\s)?!/"
        scheme="complex-sequence-nested-1" priority="low"/>
    <block start="/^\M(\s*)[\?:](\s+)\-(\s|$)/x" end="/\M^(\y1\s)?!/"
        scheme="complex-sequence" priority="low"/>

    <!-- detect complex-mapping without a value -->
    <block scheme="complex-without-value" priority="low">
        <start><![CDATA[/
            ^(\s*)\M
            [\?:]
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s)?!/]]></end>
    </block>

    <!-- detect complex-mapping with a value as a block scalar -->
    <block scheme="complex-with-value-block-scalar" priority="low">
        <start><![CDATA[/
            ^(\s*)\M
            [\?:]
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s)?!/]]></end>
    </block>

    <!-- detect complex-mapping with a value as mapping without a value -->
    <block scheme="mapping-without-value" priority="low">
        <start><![CDATA[/
            ^(\s*)
            (?{SymbolMappingComplexKey}[\?:])(\s+)
            \M%mapping-key;
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <!-- detect complex-mapping with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-with-value-block-scalar" priority="low">
        <start><![CDATA[/
            ^(\s*)
            (?{SymbolMappingComplexKey}[\?:])(\s+)
            \M%mapping-key;
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <!-- detect complex-mapping with a value as a mapping with a value -->
    <block scheme="mapping-with-value" priority="low">
        <start><![CDATA[/
            ^(\s*)
            (?{SymbolMappingComplexKey}[\?:])(\s+)
            \M%mapping-key;
            \s
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <!-- detect complex-mapping with a value -->
    <block scheme="complex-with-value" priority="low">
        <start><![CDATA[/
            ^(\s*)\M
            [\?:]
            \s+
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s)?!/]]></end>
    </block>

    <inherit scheme="badLine"/>

</scheme>

<scheme name="complex-without-value">

    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <regexp match="/~[\?:](\s+|\s*$)/" region="SymbolMappingComplexKey"/>

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->
    <inherit scheme="mapping-key-after"/>

    <!-- anything unexpected is an error -->
    <regexp match="/.?#1\s*(.+)$/" region1="Error"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <inherit scheme="document"/>

</scheme>

<scheme name="complex-with-value-block-scalar">

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <regexp match="/~[\?:](\s+|\s*$)/" region="SymbolMappingComplexKey"/>

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->
    <inherit scheme="mapping-key-after"/>

    <regexp match="/([&gt;\|])([+-])?(\d)?(\s*$|\s+#?=|\s*(?{Error}\S.*)?$)/"
        region1="BlockScalar" region2="BlockScalarIndent" region3="BlockScalarIndent"/>

    <!-- anything unexpected is an error -->
    <regexp match="/.?#1\s*(.+)$/" region1="Error"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <!-- eat empty lines -->
    <block start="/^\s*$/" end="/\M^./" scheme="def:empty"/>
    <!-- everyting else is a string -->
    <block start="/^\s+/" end="/\M^/" scheme="string" region="String" priority="low"/>

</scheme>

<scheme name="complex-with-value">

    <!-- this is what we expect exclusively at the beginning of the block (the first line) -->

    <regexp match="/~[\?:](\s+|\s*$)/" region="SymbolMappingComplexKey"/>

    <!--
        This is what we expect at the first line of the block.
        We check if we have at least one character before match to make sure we are
        in the first line. Thus, these matches will not work for the second and
        subsequent lines, as they will start at the beginning of the line.
    -->
    <inherit scheme="mapping-key-after"/>
    <inherit scheme="yaml-value"/>

    <!-- this blocks matches everything starting from the second line and below -->

    <inherit scheme="badLine"/>

</scheme>

<scheme name="complex-sequence">

    <!-- detect sequence without a value -->
    <block scheme="sequence-without-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)
            \M\-
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a block scalar -->
    <block scheme="sequence-with-value-block-scalar">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)
            \M\-
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping without a value -->
    <block scheme="mapping-without-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-with-value-block-scalar">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a mapping with a value -->
    <block scheme="mapping-with-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value -->
    <block scheme="sequence-with-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)
            \M\-
            \s+
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s)?!/]]></end>
    </block>

    <inherit scheme="sequence"/>

</scheme>

<scheme name="complex-sequence-nested-1">

    <!-- detect sequence without a value -->
    <block scheme="sequence-without-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)(?{SymbolSequence}\-)(\s+)
            \M\-
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a block scalar -->
    <block scheme="sequence-with-value-block-scalar">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)(?{SymbolSequence}\-)(\s+)
            \M\-
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping without a value -->
    <block scheme="mapping-without-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            (\s+!\S*)?
            (\s+&\S*)?
            (\s+#|\s*$)
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as mapping with a value as a block scalar -->
    <block scheme="mapping-with-value-block-scalar">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s+
            (!\S*\s+)?
            (&\S*\s+)?
            [\>\|]
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value as a mapping with a value -->
    <block scheme="mapping-with-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)(?{SymbolSequence}\-)(\s+)
            (?{SymbolSequence}\-)(\s+)
            \M%mapping-key;
            \s
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s\y4\s)?!/]]></end>
    </block>

    <!-- detect sequence with a value -->
    <block scheme="sequence-with-value">
        <start><![CDATA[/
            ~(\s*)(?{SymbolMappingComplexKey}[\?:])(\s+)(?{SymbolSequence}\-)(\s+)
            \M\-
            \s+
        /x]]></start>
        <end><![CDATA[/\M^(\y1\s\y2\s\y3\s)?!/]]></end>
    </block>

    <inherit scheme="sequence"/>

</scheme>

<scheme name="flow-mapping">
    <!-- eat spaces -->
    <regexp match="/\s+/"/>
    <!-- comments without space is an error -->
    <block start="/\s?~1#/" end="/$|\}?=/" region="Error" scheme="def:empty"/>
    <!-- comments -->
    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>
    <!-- mapping key: merge key -->
    <block start="/(&lt;&lt;)\s*(:)/" end="/[,\}]?=/" scheme="flow-mapping-value-mergekeys"
        region01="SymbolMergeKeys" region02="SymbolMapping"/>
    <!-- mapping key: double quoted -->
    <block start="/((&quot;))/" end="/((&quot;))\s*(?{Error}[^:\}]*)/" scheme="key-double-quote"
        region="MappingKey"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- mapping key: single quoted -->
    <block start="/((&apos;))/" end="/((&apos;))\s*(?{Error}[^:\}]*)/" scheme="key-single-quote"
        region="MappingKey"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- mapping key: flow-sequence -->
    <block start="/((\[))/" end="/((\]))\s*(?{Error}[^:\}]*)/" scheme="flow-sequence"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- mapping key: flow-mapping -->
    <block start="/((\{))/" end="/((\}))\s*(?{Error}[^:\}]*)/" scheme="flow-mapping"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- mapping key: plain scalar -->
    <block start="/\M[^:,\}\s]/" end="/[,:\}]?=/" scheme="key-plain" region="MappingKey"/>

    <!-- allow comma, but do not allow another comma to be used after the found comma -->
    <regexp match="/,\s*(?{Error},[\s,]*)?/" region="Symbol"/>

    <!-- mapping value -->
    <block start="/:/" end="/[,\}]?=/" region00="SymbolMapping" scheme="flow-mapping-value"/>

    <!-- anything unexpected is an error -->
    <regexp match="/\S/" region="Error" priority="low"/>
</scheme>

<scheme name="flow-mapping-value-mergekeys">
    <!-- eat spaces -->
    <regexp match="/\s+/"/>
    <!-- comments without space is an error -->
    <block start="/\s?~1#/" end="/$|\}?=/" region="Error" scheme="def:empty"/>
    <!-- comments -->
    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>
    <!-- a tag, do not allow another tag to be used after the found tag -->
    <block start="/!/" end="/\s*$|\s+(?{Error}![^,\}]*)?/" scheme="tag" region00="SymbolTag" region="Tag"/>
    <!-- anchor, do not allow anything after the found anchor -->
    <block start="/\*/" end="/\s*[,\}]?=|\s+(?{Error}[^,\}]*)/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>
    <!-- nested flow-sequence, allow only comma or closing bracket after this match -->
    <block start="/(\[)/" end="/((\]))\s*(?{Error}[^,\}]*)/" scheme="flow-sequence-mergekeys"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- anything unexpected is an error -->
    <regexp match="/\S/" region="Error" priority="low"/>
</scheme>

<scheme name="flow-mapping-value">
    <!-- eat spaces -->
    <regexp match="/\s+/"/>
    <!-- comments without space is an error -->
    <block start="/\s?~1#/" end="/$|\}?=/" region="Error" scheme="def:empty"/>
    <!-- comments -->
    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>
    <!-- a tag, do not allow another tag to be used after the found tag -->
    <block start="/!/" end="/\s*$|\s+(?{Error}![^,\}]*)?/" scheme="tag" region00="SymbolTag" region="Tag"/>
    <!-- anchor, do not allow anything after the found anchor -->
    <block start="/\*/" end="/\s*[,\}]?=|\s+(?{Error}[^,\}]*)/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>
    <!-- nested flow-sequence, allow only comma or closing bracket after this match -->
    <block start="/(\[)/" end="/((\]))\s*(?{Error}[^,\}]*)/" scheme="flow-sequence"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- nested flow-mapping, allow only comma or closing bracket after this match -->
    <block start="/(\{)/" end="/((\}))\s*(?{Error}[^,\}]*)/" scheme="flow-mapping"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- double quoted value, allow only comma or closing bracket after this match -->
    <block start="/(&quot;)/" end="/((&quot;))\s*(?{Error}[^,\}]*)/" scheme="value-double-quote"
        region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- single quoted value, allow only comma or closing bracket after this match -->
    <block start="/(&apos;)/" end="/((&apos;))\s*(?{Error}[^,\}]*)/" scheme="value-single-quote"
        region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- plain scalar value -->
    <block start="/\M[^,\}\s]/" end="/[,\}]?=/" scheme="value-plain-flow" region="String"/>
    <!-- anything unexpected is an error -->
    <regexp match="/\S/" region="Error" priority="low"/>
</scheme>

<scheme name="flow-sequence">
    <!-- eat spaces -->
    <regexp match="/\s+/"/>
    <!-- comments without space is an error -->
    <block start="/\s?~1#/" end="/$|\]?=/" region="Error" scheme="def:empty"/>
    <!-- comments -->
    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>
    <!-- a tag, do not allow another tag to be used after the found tag -->
    <block start="/!/" end="/\s*$|\s+(?{Error}![^,\]]*)?/" scheme="tag" region00="SymbolTag" region="Tag"/>
    <!-- anchor, do not allow anything after the found anchor -->
    <block start="/\*/" end="/\s*[,\]]?=|\s+(?{Error}[^,\]]*)/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>
    <!-- nested flow-sequence, allow only comma or closing bracket after this match -->
    <block start="/(\[)/" end="/((\]))\s*(?{Error}[^,\]]*)/" scheme="flow-sequence"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- nested flow-mapping, allow only comma or closing bracket after this match -->
    <block start="/(\{)/" end="/((\}))\s*(?{Error}[^,\]]*)/" scheme="flow-mapping"
        region00="SymbolFlow"    region11="SymbolFlow"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- double quoted value, allow only comma or closing bracket after this match -->
    <block start="/(&quot;)/" end="/((&quot;))\s*(?{Error}[^,\]]*)/" scheme="value-double-quote"
        region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- single quoted value, allow only comma or closing bracket after this match -->
    <block start="/(&apos;)/" end="/((&apos;))\s*(?{Error}[^,\]]*)/" scheme="value-single-quote"
        region="String"
        region00="StringEdge"    region11="StringEdge"
        region01="def:PairStart" region12="def:PairEnd"/>
    <!-- allow comma, but do not allow another comma to be used after the found comma -->
    <regexp match="/,\s*(?{Error},[\s,]*)?/" region="Symbol"/>
    <!-- plain scalar value -->
    <block start="/\M[^,\]\s]/" end="/[,\]]?=/" scheme="value-plain-flow" region="String"/>
    <!-- anything unexpected is an error -->
    <regexp match="/\S/" region="Error" priority="low"/>
</scheme>

<scheme name="flow-sequence-mergekeys">
    <!-- eat spaces -->
    <regexp match="/\s+/"/>
    <!-- comments without space is an error -->
    <block start="/\s?~1#/" end="/$|\]?=/" region="Error" scheme="def:empty"/>
    <!-- comments -->
    <block start="/#/" end="/$/" region="Comment" scheme="comment"/>
    <!-- anchor, do not allow anything after the found anchor -->
    <block start="/\*/" end="/\s*[,\]]?=|\s+(?{Error}[^,\]]*)/" scheme="anchor"
        region00="SymbolAnchor" region="Anchor"/>
    <!-- allow comma, but do not allow another comma to be used after the found comma -->
    <regexp match="/,\s*(?{Error},[\s,]*)?/" region="Symbol"/>
    <!-- anything unexpected is an error -->
    <regexp match="/\S/" region="Error" priority="low"/>
</scheme>

</type>
</hrc>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Colorer Library.
   -
   - The Initial Developer of the Original Code is
   - Cail Lomecb <cail@nm.ru>.
   - Portions created by the Initial Developer are Copyright (C) 1999-2008
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   - Konstantin Kushnir <chpock@gmail.com>.
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->
